

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Analysis &mdash; mpes 0.1 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="mpes 0.1 documentation" href="index.html"/>
        <link rel="next" title="Visualization" href="visualization.html"/>
        <link rel="prev" title="File I/O &amp; Processing" href="file_io.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> mpes
          

          
          </a>

          
            
            
              <div class="version">
                0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="file_io.html">File I/O &amp; Processing</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="visualization.html">Visualization</a></li>
<li class="toctree-l1"><a class="reference internal" href="utils.html">Utility functions</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">mpes</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Analysis</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/analysis.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="analysis">
<h1>Analysis<a class="headerlink" href="#analysis" title="Permalink to this headline">¶</a></h1>
<p>Data analysis pipeline including background removal, segmentation and fitting</p>
<span class="target" id="module-mpes.analysis"></span><p>&#64;author: R. Patrick Xian</p>
<dl class="class">
<dt id="mpes.analysis.BoundedArea">
<em class="property">class </em><code class="descclassname">mpes.analysis.</code><code class="descname">BoundedArea</code><span class="sig-paren">(</span><em>image=None</em>, <em>shape=None</em>, <em>subimage=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.BoundedArea" title="Permalink to this definition">¶</a></dt>
<dd><p>Bounded area object from a parametric equation.</p>
<dl class="attribute">
<dt id="mpes.analysis.BoundedArea.mask">
<code class="descname">mask</code><a class="headerlink" href="#mpes.analysis.BoundedArea.mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Subimage attribute as mask</p>
</dd></dl>

<dl class="method">
<dt id="mpes.analysis.BoundedArea.setBoundary">
<code class="descname">setBoundary</code><span class="sig-paren">(</span><em>pmz='linear'</em>, <em>boundtype='&gt;'</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.BoundedArea.setBoundary" title="Permalink to this definition">¶</a></dt>
<dd><p>Add bound to grid to redefine subgrid.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt>pmz <span class="classifier-delimiter">:</span> <span class="classifier">str | ‘linear’</span></dt>
<dd><p class="first last">Parametrization (pmz) of the decision boundary (‘linear’ or ‘circular’).</p>
</dd>
<dt>boundtype <span class="classifier-delimiter">:</span> <span class="classifier">str | ‘&gt;’</span></dt>
<dd><p class="first last">Bound region specification (‘&gt;’ or ‘&lt;’).</p>
</dd>
</dl>
<p class="last"><a href="#id1"><span class="problematic" id="id2">**</span></a>kwds : keyword arguments</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mpes.analysis.BoundedArea.subgrid">
<code class="descname">subgrid</code><a class="headerlink" href="#mpes.analysis.BoundedArea.subgrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Substituent pixel coordinates of the image.</p>
</dd></dl>

<dl class="method">
<dt id="mpes.analysis.BoundedArea.toMask">
<code class="descname">toMask</code><span class="sig-paren">(</span><em>inbound=1</em>, <em>exbound=0</em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.BoundedArea.toMask" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a scaled mask from existing shape.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt>inbound <span class="classifier-delimiter">:</span> <span class="classifier">float | 1</span></dt>
<dd><p class="first last">Value for the pixels within the boundary.</p>
</dd>
<dt>exbound <span class="classifier-delimiter">:</span> <span class="classifier">float | 0</span></dt>
<dd><p class="first last">Value for the pixels outside the boundary.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body"><dl class="first last docutils">
<dt>modmask <span class="classifier-delimiter">:</span> <span class="classifier">2d array</span></dt>
<dd><p class="first last">Modified mask as a 2d array.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mpes.analysis.BoundedArea.view">
<code class="descname">view</code><span class="sig-paren">(</span><em>origin='lower'</em>, <em>cmap='terrain_r'</em>, <em>axes=True</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.BoundedArea.view" title="Permalink to this definition">¶</a></dt>
<dd><p>Display the current mask.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt>origin <span class="classifier-delimiter">:</span> <span class="classifier">str | ‘lower’</span></dt>
<dd><p class="first last">Location of the image origin.</p>
</dd>
<dt>cmap <span class="classifier-delimiter">:</span> <span class="classifier">str | ‘terrain_r’</span></dt>
<dd><p class="first last">Color map</p>
</dd>
<dt>axes <span class="classifier-delimiter">:</span> <span class="classifier">bool | True</span></dt>
<dd><p class="first last">Axes visibility option in plot.</p>
</dd>
<dt><a href="#id3"><span class="problematic" id="id4">**</span></a>kwds <span class="classifier-delimiter">:</span> <span class="classifier">keyword arguments</span></dt>
<dd><p class="first last">Additional arguments for <code class="docutils literal"><span class="pre">matplotlib.pyplot.imshow()</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mpes.analysis.EnergyCalibrator">
<em class="property">class </em><code class="descclassname">mpes.analysis.</code><code class="descname">EnergyCalibrator</code><span class="sig-paren">(</span><em>biases=None</em>, <em>files=[]</em>, <em>folder=[]</em>, <em>file_sorting=True</em>, <em>traces=None</em>, <em>tof=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.EnergyCalibrator" title="Permalink to this definition">¶</a></dt>
<dd><p>Electron binding energy calibration workflow.</p>
<dl class="method">
<dt id="mpes.analysis.EnergyCalibrator.addFeatures">
<code class="descname">addFeatures</code><span class="sig-paren">(</span><em>ranges</em>, <em>refid=0</em>, <em>traces=None</em>, <em>infer_others=False</em>, <em>mode='append'</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.EnergyCalibrator.addFeatures" title="Permalink to this definition">¶</a></dt>
<dd><p>Select or extract the equivalent landmarks (e.g. peaks) among all traces.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt>ranges <span class="classifier-delimiter">:</span> <span class="classifier">list/tuple</span></dt>
<dd><p class="first last">Collection of feature detection ranges, within which an algorithm
(i.e. 1D peak detector) with look for the feature.</p>
</dd>
<dt>refid <span class="classifier-delimiter">:</span> <span class="classifier">int | 0</span></dt>
<dd><p class="first last">Index of the reference trace (EDC).</p>
</dd>
<dt>traces <span class="classifier-delimiter">:</span> <span class="classifier">2D array | None</span></dt>
<dd><p class="first last">Collection of energy dispersion curves (EDCs).</p>
</dd>
<dt>infer_others <span class="classifier-delimiter">:</span> <span class="classifier">bool | True</span></dt>
<dd><p class="first last">Option to infer the feature detection range in other traces (EDCs) from a given one.</p>
</dd>
<dt>mode <span class="classifier-delimiter">:</span> <span class="classifier">str | ‘append’</span></dt>
<dd><p class="first last">Specification on how to change the feature ranges (‘append’ or ‘replace’).</p>
</dd>
<dt><a href="#id5"><span class="problematic" id="id6">**</span></a>kwds <span class="classifier-delimiter">:</span> <span class="classifier">keyword arguments</span></dt>
<dd><p class="first last">Dictionarized keyword arguments for trace alignment (See <code class="docutils literal"><span class="pre">self.findCorrespondence()</span></code>)</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mpes.analysis.EnergyCalibrator.calibrate">
<code class="descname">calibrate</code><span class="sig-paren">(</span><em>refid=0, ret=['coeffs'], **kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.EnergyCalibrator.calibrate" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the functional mapping between time-of-flight and the energy
scale using optimization methods.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt>refid <span class="classifier-delimiter">:</span> <span class="classifier">int | 0</span></dt>
<dd><p class="first last">The reference trace index (an integer).</p>
</dd>
<dt>ret <span class="classifier-delimiter">:</span> <span class="classifier">list | [‘coeffs’]</span></dt>
<dd><p class="first last">Options for return values (see <code class="docutils literal"><span class="pre">mpes.analysis.calibrateE()</span></code>).</p>
</dd>
<dt><a href="#id7"><span class="problematic" id="id8">**</span></a>kwds <span class="classifier-delimiter">:</span> <span class="classifier">keyword arguments</span></dt>
<dd><p class="first last">See available keywords for <code class="docutils literal"><span class="pre">mpes.analysis.calibrateE()</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mpes.analysis.EnergyCalibrator.dup">
<code class="descname">dup</code><a class="headerlink" href="#mpes.analysis.EnergyCalibrator.dup" title="Permalink to this definition">¶</a></dt>
<dd><p>The duplication number.</p>
</dd></dl>

<dl class="method">
<dt id="mpes.analysis.EnergyCalibrator.featureExtract">
<code class="descname">featureExtract</code><span class="sig-paren">(</span><em>ranges=None</em>, <em>traces=None</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.EnergyCalibrator.featureExtract" title="Permalink to this definition">¶</a></dt>
<dd><p>Select or extract the equivalent landmarks (e.g. peaks) among all traces.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first">ranges : list | None
traces : 2D array | None
<a href="#id9"><span class="problematic" id="id10">**</span></a>kwds : keyword arguments</p>
<blockquote class="last">
<div><p>See available keywords in <code class="docutils literal"><span class="pre">mpes.analysis.peaksearch()</span></code>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="mpes.analysis.EnergyCalibrator.findCorrespondence">
<em class="property">static </em><code class="descname">findCorrespondence</code><span class="sig-paren">(</span><em>sig_still</em>, <em>sig_mov</em>, <em>method='dtw'</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.EnergyCalibrator.findCorrespondence" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine the correspondence between two 1D traces by alignment.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt>sig_still, sig_mov <span class="classifier-delimiter">:</span> <span class="classifier">1D array, 1D array</span></dt>
<dd><p class="first last">Input 1D signals.</p>
</dd>
<dt>method <span class="classifier-delimiter">:</span> <span class="classifier">str | ‘dtw’</span></dt>
<dd><p class="first last">Method for 1D signal correspondence detection (‘dtw’ or ‘ptw’).</p>
</dd>
<dt><a href="#id11"><span class="problematic" id="id12">**</span></a>kwds <span class="classifier-delimiter">:</span> <span class="classifier">keyword arguments</span></dt>
<dd><p class="first last">See available keywords for the following functions,
(1) <code class="docutils literal"><span class="pre">fastdtw.fastdtw()</span></code> (when <code class="docutils literal"><span class="pre">method=='dtw'</span></code>)
(2) <code class="docutils literal"><span class="pre">ptw.ptw.timeWarp()</span></code> (when <code class="docutils literal"><span class="pre">method=='ptw'</span></code>)</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body"><dl class="first last docutils">
<dt>pathcorr <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">Pixel-wise path correspondences between two input 1D arrays (sig_still, sig_mov).</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mpes.analysis.EnergyCalibrator.nfiles">
<code class="descname">nfiles</code><a class="headerlink" href="#mpes.analysis.EnergyCalibrator.nfiles" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of loaded files.</p>
</dd></dl>

<dl class="method">
<dt id="mpes.analysis.EnergyCalibrator.normalize">
<code class="descname">normalize</code><span class="sig-paren">(</span><em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.EnergyCalibrator.normalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Normalize the spectra along an axis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><a href="#id13"><span class="problematic" id="id14">**</span></a>kwds <span class="classifier-delimiter">:</span> <span class="classifier">keyword arguments</span></dt>
<dd><p class="first last">See the keywords for <code class="docutils literal"><span class="pre">mpes.utils.normspec()</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mpes.analysis.EnergyCalibrator.nranges">
<code class="descname">nranges</code><a class="headerlink" href="#mpes.analysis.EnergyCalibrator.nranges" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of specified feature ranges.</p>
</dd></dl>

<dl class="attribute">
<dt id="mpes.analysis.EnergyCalibrator.ntraces">
<code class="descname">ntraces</code><a class="headerlink" href="#mpes.analysis.EnergyCalibrator.ntraces" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of loaded/calculated traces.</p>
</dd></dl>

<dl class="method">
<dt id="mpes.analysis.EnergyCalibrator.read">
<code class="descname">read</code><span class="sig-paren">(</span><em>form='h5'</em>, <em>tracename=''</em>, <em>tofname='ToF'</em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.EnergyCalibrator.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Read traces (e.g. energy dispersion curves) from files.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt>form <span class="classifier-delimiter">:</span> <span class="classifier">str | ‘h5’</span></dt>
<dd><p class="first last">Format of the files (‘h5’ or ‘mat’).</p>
</dd>
<dt>tracename <span class="classifier-delimiter">:</span> <span class="classifier">str | ‘’</span></dt>
<dd><p class="first last">Name of the group/attribute corresponding to the trace.</p>
</dd>
<dt>tofname <span class="classifier-delimiter">:</span> <span class="classifier">str | ‘ToF’</span></dt>
<dd><p class="first last">Name of the group/attribute corresponding to the time-of-flight.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mpes.analysis.EnergyCalibrator.saveParameters">
<code class="descname">saveParameters</code><span class="sig-paren">(</span><em>form='h5'</em>, <em>save_addr='./energy'</em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.EnergyCalibrator.saveParameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Save all the attributes of the workflow instance for later use
(e.g. energy scale conversion).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt>form <span class="classifier-delimiter">:</span> <span class="classifier">str | ‘h5’</span></dt>
<dd><p class="first last">The file format to save the attributes in (‘h5’/’hdf5’ or ‘mat’).</p>
</dd>
<dt>save_addr <span class="classifier-delimiter">:</span> <span class="classifier">str | ‘./energy’</span></dt>
<dd><p class="first last">The filename to save the files with.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mpes.analysis.EnergyCalibrator.view">
<code class="descname">view</code><span class="sig-paren">(</span><em>traces</em>, <em>segs=None</em>, <em>ranges=None</em>, <em>peaks=None</em>, <em>show_legend=True</em>, <em>ret=False</em>, <em>display=True</em>, <em>backend='matplotlib'</em>, <em>linekwds={}</em>, <em>linesegkwds={}</em>, <em>scatterkwds={}</em>, <em>legkwds={}</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.EnergyCalibrator.view" title="Permalink to this definition">¶</a></dt>
<dd><p>Display a plot showing line traces with annotation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt>traces <span class="classifier-delimiter">:</span> <span class="classifier">2d array</span></dt>
<dd><p class="first last">Matrix of traces to visualize.</p>
</dd>
</dl>
<p>segs :
ranges :
peaks : 2d array</p>
<blockquote>
<div><p>Peak positions for labelling the traces.</p>
</div></blockquote>
<dl class="last docutils">
<dt>ret <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Return specification.</p>
</dd>
<dt>backend <span class="classifier-delimiter">:</span> <span class="classifier">str | ‘matplotlib’</span></dt>
<dd><p class="first last">Backend specification, choose between ‘matplotlib’ (static) or ‘bokeh’ (interactive).</p>
</dd>
<dt>linekwds <span class="classifier-delimiter">:</span> <span class="classifier">dict | {}</span></dt>
<dd><p class="first last">Keyword arguments for line plotting (see <code class="docutils literal"><span class="pre">matplotlib.pyplot.plot()</span></code>).</p>
</dd>
<dt>scatterkwds <span class="classifier-delimiter">:</span> <span class="classifier">dict | {}</span></dt>
<dd><p class="first last">Keyword arguments for scatter plot (see <code class="docutils literal"><span class="pre">matplotlib.pyplot.scatter()</span></code>).</p>
</dd>
<dt>legkwds <span class="classifier-delimiter">:</span> <span class="classifier">dict | {}</span></dt>
<dd><p class="first last">Keyword arguments for legend (see <code class="docutils literal"><span class="pre">matplotlib.pyplot.legend()</span></code>).</p>
</dd>
<dt><a href="#id15"><span class="problematic" id="id16">**</span></a>kwds <span class="classifier-delimiter">:</span> <span class="classifier">keyword arguments</span></dt>
<dd><table border="1" class="first last docutils">
<colgroup>
<col width="26%" />
<col width="18%" />
<col width="56%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">keyword</th>
<th class="head">data type</th>
<th class="head">meaning</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>maincolor</td>
<td>str</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>labels</td>
<td>list</td>
<td>Labels for each curve</td>
</tr>
<tr class="row-even"><td>xaxis</td>
<td>1d array</td>
<td>x (horizontal) axis values</td>
</tr>
<tr class="row-odd"><td>title</td>
<td>str</td>
<td>Title of the plot</td>
</tr>
<tr class="row-even"><td>legend_location</td>
<td>str</td>
<td>Location of the plot legend</td>
</tr>
</tbody>
</table>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mpes.analysis.Model">
<em class="property">class </em><code class="descclassname">mpes.analysis.</code><code class="descname">Model</code><span class="sig-paren">(</span><em>func</em>, <em>xvar</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.Model" title="Permalink to this definition">¶</a></dt>
<dd><p>Class of fitting curve models</p>
<dl class="method">
<dt id="mpes.analysis.Model.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>data</em>, <em>inits</em>, <em>method='leastsq'</em>, <em>**fitkwds</em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.Model.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Run the optimization</p>
</dd></dl>

<dl class="method">
<dt id="mpes.analysis.Model.model_eval">
<code class="descname">model_eval</code><span class="sig-paren">(</span><em>params</em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.Model.model_eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the fitting model with given parameters</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mpes.analysis.Model.normalize">
<em class="property">static </em><code class="descname">normalize</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.Model.normalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Normalize n-dimensional data</p>
</dd></dl>

<dl class="method">
<dt id="mpes.analysis.Model.partial_eval">
<code class="descname">partial_eval</code><span class="sig-paren">(</span><em>params</em>, <em>part=0</em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.Model.partial_eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate parts of a composite fitting model</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mpes.analysis.MomentumCorrector">
<em class="property">class </em><code class="descclassname">mpes.analysis.</code><code class="descname">MomentumCorrector</code><span class="sig-paren">(</span><em>image</em>, <em>rotsym=6</em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.MomentumCorrector" title="Permalink to this definition">¶</a></dt>
<dd><p>Momentum distortion correction and momentum calibration workflow.</p>
<dl class="method">
<dt id="mpes.analysis.MomentumCorrector.applyDeformation">
<code class="descname">applyDeformation</code><span class="sig-paren">(</span><em>image</em>, <em>ret=True</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.MomentumCorrector.applyDeformation" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the deformation field to a specified image slice.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt>image <span class="classifier-delimiter">:</span> <span class="classifier">2D array</span></dt>
<dd><p class="first last">Image slice to apply the deformation.</p>
</dd>
<dt>ret <span class="classifier-delimiter">:</span> <span class="classifier">bool | True</span></dt>
<dd><p class="first last">Option to return the image after deformation.</p>
</dd>
<dt><a href="#id17"><span class="problematic" id="id18">**</span></a>kwds <span class="classifier-delimiter">:</span> <span class="classifier">keyword arguments</span></dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">rdeform, cdeform:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body">2D array, 2D array | self.rdeform_field, self.cdeform_field
Row- and column-ordered deformation fields.</td>
</tr>
<tr class="field-even field"><th class="field-name">interp_order:</th><td class="field-body">int | 1
Interpolation order.</td>
</tr>
<tr class="field-odd field"><th class="field-name">others:</th><td class="field-body">See <code class="docutils literal"><span class="pre">scipy.ndimage.map_coordinates()</span></code>.</td>
</tr>
</tbody>
</table>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mpes.analysis.MomentumCorrector.calcGeometricDistances">
<code class="descname">calcGeometricDistances</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.MomentumCorrector.calcGeometricDistances" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate geometric distances involving the center and the vertices.
Distances calculated include center-vertex and nearest-neighbor vertex-vertex distances.</p>
</dd></dl>

<dl class="method">
<dt id="mpes.analysis.MomentumCorrector.calcSymmetryScores">
<code class="descname">calcSymmetryScores</code><span class="sig-paren">(</span><em>symtype='rotation'</em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.MomentumCorrector.calcSymmetryScores" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the symmetry scores from geometric quantities.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Paramters:</th><td class="field-body"><dl class="first last docutils">
<dt>symtype <span class="classifier-delimiter">:</span> <span class="classifier">str | ‘rotation’</span></dt>
<dd><p class="first last">Type of symmetry.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mpes.analysis.MomentumCorrector.calibrate">
<code class="descname">calibrate</code><span class="sig-paren">(</span><em>image</em>, <em>point_from</em>, <em>point_to</em>, <em>dist</em>, <em>ret='coeffs'</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.MomentumCorrector.calibrate" title="Permalink to this definition">¶</a></dt>
<dd><p>Calibration of the momentum axes. Obtain all calibration-related values,
return only the ones requested.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt>image <span class="classifier-delimiter">:</span> <span class="classifier">2d array</span></dt>
<dd><p class="first last">Image slice to construct the calibration function.</p>
</dd>
<dt>point_from, point_to <span class="classifier-delimiter">:</span> <span class="classifier">list/tuple, list/tuple</span></dt>
<dd><p class="first last">Pixel coordinates of the two special points in (row, col) ordering.</p>
</dd>
<dt>dist <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Distance between the two selected points in inverse Angstrom.</p>
</dd>
<dt>ret <span class="classifier-delimiter">:</span> <span class="classifier">str | ‘coeffs’</span></dt>
<dd><p class="first last">Specification of return values (‘axes’, ‘extent’, ‘coeffs’, ‘grid’, ‘func’, ‘all’).</p>
</dd>
<dt><a href="#id19"><span class="problematic" id="id20">**</span></a>kwds <span class="classifier-delimiter">:</span> <span class="classifier">keyword arguments</span></dt>
<dd><p class="first last">See arguments in <code class="docutils literal"><span class="pre">mpes.analysis.calibrateE()</span></code>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body"><p class="first last">Specified calibration parameters in a dictionary.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mpes.analysis.MomentumCorrector.coordinateTransform">
<code class="descname">coordinateTransform</code><span class="sig-paren">(</span><em>type</em>, <em>keep=False</em>, <em>ret=False</em>, <em>interp_order=1</em>, <em>mapkwds={}</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.MomentumCorrector.coordinateTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a pixel-wise coordinate transform to an image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt>type <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Type of deformation to apply to image slice.</p>
</dd>
<dt>keep <span class="classifier-delimiter">:</span> <span class="classifier">bool | False</span></dt>
<dd><p class="first last">Option to keep the specified coordinate transform.</p>
</dd>
<dt>ret <span class="classifier-delimiter">:</span> <span class="classifier">bool | False</span></dt>
<dd><p class="first last">Option to return transformed image slice.</p>
</dd>
<dt>interp_order <span class="classifier-delimiter">:</span> <span class="classifier">int | 1</span></dt>
<dd><p class="first last">Interpolation order for filling in missed pixels.</p>
</dd>
<dt>mapkwds <span class="classifier-delimiter">:</span> <span class="classifier">dict | {}</span></dt>
<dd><p class="first last">Additional arguments passed to <code class="docutils literal"><span class="pre">scipy.ndimage.map_coordinates()</span></code>.</p>
</dd>
<dt><a href="#id21"><span class="problematic" id="id22">**</span></a>kwds <span class="classifier-delimiter">:</span> <span class="classifier">keyword arguments</span></dt>
<dd><p class="first last">Additional arguments in specific deformation field. See <code class="docutils literal"><span class="pre">symmetrize.sym</span></code> module.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mpes.analysis.MomentumCorrector.correct">
<code class="descname">correct</code><span class="sig-paren">(</span><em>axis</em>, <em>use_composite_transform=False</em>, <em>update=False</em>, <em>use_deform_field=False</em>, <em>updatekwds={}</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.MomentumCorrector.correct" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a 2D transform to a stack of 2D images (3D) along a specific axis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Axis for slice selection.</p>
</dd>
<dt>use_composite_transform <span class="classifier-delimiter">:</span> <span class="classifier">bool | False</span></dt>
<dd><p class="first last">Option to use the composite transform involving the rotation.</p>
</dd>
<dt>update <span class="classifier-delimiter">:</span> <span class="classifier">bool | False</span></dt>
<dd><p class="first last">Option to update the existing figure attributes.</p>
</dd>
<dt>use_deform_field <span class="classifier-delimiter">:</span> <span class="classifier">bool | False</span></dt>
<dd><p class="first last">Option to use deformation field for distortion correction.</p>
</dd>
<dt><a href="#id23"><span class="problematic" id="id24">**</span></a>kwds <span class="classifier-delimiter">:</span> <span class="classifier">keyword arguments</span></dt>
<dd><table border="1" class="first last docutils">
<colgroup>
<col width="14%" />
<col width="20%" />
<col width="66%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">keyword</th>
<th class="head">data type</th>
<th class="head">meaning</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>image</td>
<td>2d array</td>
<td>3D image for correction</td>
</tr>
<tr class="row-odd"><td>dfield</td>
<td>list/tuple</td>
<td>row and column deformation field</td>
</tr>
<tr class="row-even"><td>warping</td>
<td>2d array</td>
<td>2D transform correction matrix</td>
</tr>
</tbody>
</table>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mpes.analysis.MomentumCorrector.featureExtract">
<code class="descname">featureExtract</code><span class="sig-paren">(</span><em>image</em>, <em>direction='ccw'</em>, <em>type='points'</em>, <em>center_det='centroidnn'</em>, <em>symscores=True</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.MomentumCorrector.featureExtract" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Extract features from the selected 2D slice.</dt>
<dd>Currently only point feature detection is implemented.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt>image <span class="classifier-delimiter">:</span> <span class="classifier">2d array</span></dt>
<dd><p class="first last">The image slice to extract features from.</p>
</dd>
<dt>direction <span class="classifier-delimiter">:</span> <span class="classifier">str | ‘ccw’</span></dt>
<dd><p class="first last">The circular direction to reorder the features in (‘cw’ or ‘ccw’).</p>
</dd>
<dt>type <span class="classifier-delimiter">:</span> <span class="classifier">str | ‘points’</span></dt>
<dd><p class="first last">The type of features to extract.</p>
</dd>
<dt>center_det <span class="classifier-delimiter">:</span> <span class="classifier">str | ‘centroidnn’</span></dt>
<dd><p class="first last">Specification of center detection method (‘centroidnn’, ‘centroid’, None).</p>
</dd>
<dt><a href="#id25"><span class="problematic" id="id26">**</span></a>kwds <span class="classifier-delimiter">:</span> <span class="classifier">keyword arguments</span></dt>
<dd><p class="first last">Extra keyword arguments for <code class="docutils literal"><span class="pre">symmetrize.pointops.peakdetect2d()</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mpes.analysis.MomentumCorrector.features">
<code class="descname">features</code><a class="headerlink" href="#mpes.analysis.MomentumCorrector.features" title="Permalink to this definition">¶</a></dt>
<dd><p>Dictionary of detected features for the symmetrization process.
<code class="docutils literal"><span class="pre">self.features</span></code> is a derived attribute from existing ones.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mpes.analysis.MomentumCorrector.getWarpFunction">
<em class="property">static </em><code class="descname">getWarpFunction</code><span class="sig-paren">(</span><em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.MomentumCorrector.getWarpFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct warping function to apply to other datasets.
# TODO: turn this into a fully operational method.</p>
</dd></dl>

<dl class="method">
<dt id="mpes.analysis.MomentumCorrector.linWarpEstimate">
<code class="descname">linWarpEstimate</code><span class="sig-paren">(</span><em>weights=(1</em>, <em>1</em>, <em>1)</em>, <em>optfunc='minimize'</em>, <em>optmethod='Nelder-Mead'</em>, <em>ret=True</em>, <em>warpkwds={}</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.MomentumCorrector.linWarpEstimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the homography-based deformation field using landmark correspondences.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt>weights <span class="classifier-delimiter">:</span> <span class="classifier">tuple/list/array | (1, 1, 1)</span></dt>
<dd><p class="first last">Weights added to the terms in the optimizer. The terms are assigned
to the cost functions of (1) centeredness, (2) center-vertex symmetry,
(3) vertex-vertex symmetry, respectively.</p>
</dd>
<dt>optfunc, optmethod <span class="classifier-delimiter">:</span> <span class="classifier">str/func, str | ‘minimize’, ‘Nelder-Mead’</span></dt>
<dd><p class="first last">Name of the optimizer function and the optimization method.
See description in <code class="docutils literal"><span class="pre">mpes.analysis.sym.refsetopt()</span></code>.</p>
</dd>
<dt>ret <span class="classifier-delimiter">:</span> <span class="classifier">bool | True</span></dt>
<dd><p class="first last">Specify if returning the corrected image slice.</p>
</dd>
<dt>warpkwds <span class="classifier-delimiter">:</span> <span class="classifier">dictionary | {}</span></dt>
<dd><p class="first last">Additional arguments passed to <code class="docutils literal"><span class="pre">symmetrize.sym.imgWarping()</span></code>.</p>
</dd>
<dt><a href="#id27"><span class="problematic" id="id28">**</span></a>kwds <span class="classifier-delimiter">:</span> <span class="classifier">keyword arguments</span></dt>
<dd><table border="1" class="first last docutils">
<colgroup>
<col width="14%" />
<col width="16%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">keyword</th>
<th class="head">data type</th>
<th class="head">meaning</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>niter</td>
<td>int</td>
<td>Maximum number of iterations</td>
</tr>
<tr class="row-odd"><td>landmarks</td>
<td>list/array</td>
<td>Symmetry landmarks selected for registration</td>
</tr>
<tr class="row-even"><td>fitinit</td>
<td>tuple/list</td>
<td>Initial conditions for fitting</td>
</tr>
</tbody>
</table>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body"><p class="first last">Corrected 2D image slice (when <code class="docutils literal"><span class="pre">ret=True</span></code> is specified in the arguments).</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mpes.analysis.MomentumCorrector.resetDeformation">
<code class="descname">resetDeformation</code><span class="sig-paren">(</span><em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.MomentumCorrector.resetDeformation" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset the deformation field.</p>
</dd></dl>

<dl class="method">
<dt id="mpes.analysis.MomentumCorrector.rotate">
<code class="descname">rotate</code><span class="sig-paren">(</span><em>angle='auto'</em>, <em>ret=False</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.MomentumCorrector.rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate 2D image in the homogeneous coordinate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt>angle <span class="classifier-delimiter">:</span> <span class="classifier">float/str</span></dt>
<dd><p class="first last">Angle of rotation (specify ‘auto’ to use automated estimation).</p>
</dd>
<dt>ret <span class="classifier-delimiter">:</span> <span class="classifier">bool | False</span></dt>
<dd><p class="first last">Return specification (True/False)</p>
</dd>
<dt><a href="#id29"><span class="problematic" id="id30">**</span></a>kwds <span class="classifier-delimiter">:</span> <span class="classifier">keyword arguments</span></dt>
<dd><table border="1" class="first docutils">
<colgroup>
<col width="13%" />
<col width="18%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">keyword</th>
<th class="head">data type</th>
<th class="head">meaning</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>image</td>
<td>2d array</td>
<td>2D image for correction</td>
</tr>
<tr class="row-odd"><td>center</td>
<td>tuple/list</td>
<td>pixel coordinates of the image center</td>
</tr>
<tr class="row-even"><td>scale</td>
<td>float</td>
<td>scaling factor in rotation</td>
</tr>
</tbody>
</table>
<p class="last">See <code class="docutils literal"><span class="pre">symmetrize.sym.sym_pose_estimate()</span></code> for other keywords.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mpes.analysis.MomentumCorrector.saveImage">
<code class="descname">saveImage</code><span class="sig-paren">(</span><em>form='tiff'</em>, <em>save_addr='./'</em>, <em>dtyp='float32'</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.MomentumCorrector.saveImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Save the distortion-corrected dataset (image only, without axes).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt>form <span class="classifier-delimiter">:</span> <span class="classifier">str | ‘tiff’</span></dt>
<dd><p class="first last">File format for saving the corrected image (‘tiff’ or ‘mat’).</p>
</dd>
<dt>save_addr <span class="classifier-delimiter">:</span> <span class="classifier">str | ‘./’</span></dt>
<dd><p class="first last">The address to save the file at.</p>
</dd>
<dt>dtyp <span class="classifier-delimiter">:</span> <span class="classifier">str | ‘float32’</span></dt>
<dd><p class="first last">Data type (in case conversion if needed).</p>
</dd>
<dt><a href="#id31"><span class="problematic" id="id32">**</span></a>kwds <span class="classifier-delimiter">:</span> <span class="classifier">keyword arguments</span></dt>
<dd><p class="first last">See keywords from <code class="docutils literal"><span class="pre">tifffile.imsave()</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mpes.analysis.MomentumCorrector.saveParameters">
<code class="descname">saveParameters</code><span class="sig-paren">(</span><em>form='h5'</em>, <em>save_addr='./momentum'</em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.MomentumCorrector.saveParameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Save all the attributes of the workflow instance for later use
(e.g. momentum scale conversion, reconstructing the warping map function).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt>form <span class="classifier-delimiter">:</span> <span class="classifier">str | ‘h5’</span></dt>
<dd><p class="first last">File format to for saving the parameters (‘h5’/’hdf5’, ‘mat’)</p>
</dd>
<dt>save_addr <span class="classifier-delimiter">:</span> <span class="classifier">str | ‘./momentum’</span></dt>
<dd><p class="first last">The address for the to be saved file.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mpes.analysis.MomentumCorrector.selectSlice2D">
<code class="descname">selectSlice2D</code><span class="sig-paren">(</span><em>selector</em>, <em>axis=2</em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.MomentumCorrector.selectSlice2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Select (hyper)slice from a (hyper)volume.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt>selector <span class="classifier-delimiter">:</span> <span class="classifier">slice object/list/int</span></dt>
<dd><p class="first last">Selector along the specified axis to extract the slice (image).
Use the construct slice(start, stop, step) to select a range of images and sum them.
Use an integer to specify only a particular slice.</p>
</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int | 2</span></dt>
<dd><p class="first last">Axis along which to select the image.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mpes.analysis.MomentumCorrector.splineWarpEstimate">
<code class="descname">splineWarpEstimate</code><span class="sig-paren">(</span><em>image</em>, <em>include_center=True</em>, <em>fixed_center=True</em>, <em>iterative=False</em>, <em>interp_order=1</em>, <em>update=False</em>, <em>ret=False</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.MomentumCorrector.splineWarpEstimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the spline deformation field using thin plate spline registration.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt>image <span class="classifier-delimiter">:</span> <span class="classifier">2D array</span></dt>
<dd><p class="first last">Image slice to be corrected.</p>
</dd>
<dt>include_center <span class="classifier-delimiter">:</span> <span class="classifier">bool | True</span></dt>
<dd><p class="first last">Option to include the image center/centroid in the registration process.</p>
</dd>
<dt>fixed_center <span class="classifier-delimiter">:</span> <span class="classifier">bool | True</span></dt>
<dd><p class="first last">Option to have a fixed center during registration-based symmetrization.</p>
</dd>
<dt>iterative <span class="classifier-delimiter">:</span> <span class="classifier">bool | False</span></dt>
<dd><p class="first last">Option to use the iterative approach (may not work in all cases).</p>
</dd>
<dt>interp_order <span class="classifier-delimiter">:</span> <span class="classifier">int | 1</span></dt>
<dd><p class="first last">Order of interpolation (see <code class="docutils literal"><span class="pre">scipy.ndimage.map_coordinates()</span></code>).</p>
</dd>
<dt>update <span class="classifier-delimiter">:</span> <span class="classifier">bool | False</span></dt>
<dd><p class="first last">Option to keep the spline-deformed image as corrected one.</p>
</dd>
<dt>ret <span class="classifier-delimiter">:</span> <span class="classifier">bool | False</span></dt>
<dd><p class="first last">Option to return corrected image slice.</p>
</dd>
<dt><a href="#id33"><span class="problematic" id="id34">**</span></a>kwds <span class="classifier-delimiter">:</span> <span class="classifier">keyword arguments</span></dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">landmarks:</th><td class="field-body">list/array | self.pouter_ord
Landmark positions (row, column) used for registration.</td>
</tr>
<tr class="field-even field"><th class="field-name">new_centers:</th><td class="field-body">dict | {}
User-specified center positions for the reference and target sets.
{‘lmkcenter’: (row, col), ‘refcenter’: (row, col)}</td>
</tr>
</tbody>
</table>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mpes.analysis.MomentumCorrector.symscores">
<code class="descname">symscores</code><a class="headerlink" href="#mpes.analysis.MomentumCorrector.symscores" title="Permalink to this definition">¶</a></dt>
<dd><p>Dictionary of symmetry-related scores.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mpes.analysis.MomentumCorrector.transform">
<em class="property">static </em><code class="descname">transform</code><span class="sig-paren">(</span><em>points</em>, <em>transmat</em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.MomentumCorrector.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Coordinate transform of a point set in the (row, column) formulation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt>points <span class="classifier-delimiter">:</span> <span class="classifier">list/array</span></dt>
<dd><p class="first last">Cartesian pixel coordinates of the points to be transformed.</p>
</dd>
<dt>transmat <span class="classifier-delimiter">:</span> <span class="classifier">2D array</span></dt>
<dd><p class="first last">The transform matrix.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body"><p class="first last">Transformed point coordinates.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mpes.analysis.MomentumCorrector.update">
<code class="descname">update</code><span class="sig-paren">(</span><em>content</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.MomentumCorrector.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Update specific attributes of the class.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt>content <span class="classifier-delimiter">:</span> <span class="classifier">str | ‘all’</span></dt>
<dd><p class="first last">‘feature’ = update only feature attributes
‘image’ = update only image-related attributes
‘all’ = update both feature and image-related attributes</p>
</dd>
<dt><a href="#id35"><span class="problematic" id="id36">**</span></a>kwds <span class="classifier-delimiter">:</span> <span class="classifier">keyword arguments</span></dt>
<dd><p class="first last">Extra keyword arguments passed into <code class="docutils literal"><span class="pre">self._featureUpdate()</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mpes.analysis.MomentumCorrector.updateDeformation">
<code class="descname">updateDeformation</code><span class="sig-paren">(</span><em>rdisp</em>, <em>cdisp</em>, <em>reset=False</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.MomentumCorrector.updateDeformation" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the deformation field.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt>rdisp, cdisp <span class="classifier-delimiter">:</span> <span class="classifier">2D array, 2D array</span></dt>
<dd><p class="first last">Row- and column-ordered displacement fields.</p>
</dd>
<dt>reset <span class="classifier-delimiter">:</span> <span class="classifier">bool | False</span></dt>
<dd><p class="first last">Option to reset the deformation field.</p>
</dd>
<dt><a href="#id37"><span class="problematic" id="id38">**</span></a>kwds <span class="classifier-delimiter">:</span> <span class="classifier">keyword arguments</span></dt>
<dd><p class="first last">See <code class="docutils literal"><span class="pre">mpes.analysis.MomentumCorrector.resetDeformation()</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mpes.analysis.MomentumCorrector.view">
<code class="descname">view</code><span class="sig-paren">(</span><em>origin='lower'</em>, <em>cmap='terrain_r'</em>, <em>figsize=(4</em>, <em>4)</em>, <em>points={}</em>, <em>annotated=False</em>, <em>display=True</em>, <em>backend='matplotlib'</em>, <em>ret=False</em>, <em>imkwds={}</em>, <em>scatterkwds={}</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.MomentumCorrector.view" title="Permalink to this definition">¶</a></dt>
<dd><p>Display image slice with specified annotations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt>origin <span class="classifier-delimiter">:</span> <span class="classifier">str | ‘lower’</span></dt>
<dd><p class="first last">Figure origin specification (‘lower’ or ‘upper’).</p>
</dd>
<dt>cmap <span class="classifier-delimiter">:</span> <span class="classifier">str | ‘terrain_r’</span></dt>
<dd><p class="first last">Colormap specification.</p>
</dd>
<dt>figsize <span class="classifier-delimiter">:</span> <span class="classifier">tuple/list | (4, 4)</span></dt>
<dd><p class="first last">Figure size.</p>
</dd>
<dt>points <span class="classifier-delimiter">:</span> <span class="classifier">dict | {}</span></dt>
<dd><p class="first last">Points for annotation.</p>
</dd>
<dt>annotated <span class="classifier-delimiter">:</span> <span class="classifier">bool | False</span></dt>
<dd><p class="first last">Option for annotation.</p>
</dd>
<dt>display <span class="classifier-delimiter">:</span> <span class="classifier">bool | True</span></dt>
<dd><p class="first last">Display option when using <code class="docutils literal"><span class="pre">bokeh</span></code> to render interactively.</p>
</dd>
<dt>backend <span class="classifier-delimiter">:</span> <span class="classifier">str | ‘matplotlib’</span></dt>
<dd><p class="first last">Visualization backend specification.
:’matplotlib’: use static display rendered by matplotlib.
:’bokeh’: use interactive display rendered by bokeh.</p>
</dd>
<dt>ret <span class="classifier-delimiter">:</span> <span class="classifier">bool | False</span></dt>
<dd><p class="first last">Option to return figure and axis objects.</p>
</dd>
<dt>imkwd <span class="classifier-delimiter">:</span> <span class="classifier">dict | {}</span></dt>
<dd><p class="first last">Keyword arguments for <code class="docutils literal"><span class="pre">matplotlib.pyplot.imshow()</span></code>.</p>
</dd>
<dt><a href="#id39"><span class="problematic" id="id40">**</span></a>kwds <span class="classifier-delimiter">:</span> <span class="classifier">keyword arguments</span></dt>
<dd><p class="first last">General extra arguments for the plotting procedure.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="mpes.analysis.affineWarping">
<code class="descclassname">mpes.analysis.</code><code class="descname">affineWarping</code><span class="sig-paren">(</span><em>img</em>, <em>landmarks</em>, <em>refs</em>, <em>ret='image'</em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.affineWarping" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform image warping based on a generic affine transform (homography).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt>img <span class="classifier-delimiter">:</span> <span class="classifier">2D array</span></dt>
<dd><p class="first last">Input image (distorted)</p>
</dd>
<dt>landmarks <span class="classifier-delimiter">:</span> <span class="classifier">list/array</span></dt>
<dd><p class="first last">List of pixel positions of the</p>
</dd>
<dt>refs <span class="classifier-delimiter">:</span> <span class="classifier">list/array</span></dt>
<dd><p class="first last">List of pixel positions of regular</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt>imgaw <span class="classifier-delimiter">:</span> <span class="classifier">2D array</span></dt>
<dd><p class="first last">Image after affine warping.</p>
</dd>
<dt>maw <span class="classifier-delimiter">:</span> <span class="classifier">2D array</span></dt>
<dd><p class="first last">Homography matrix for the tranform.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mpes.analysis.applyWarping">
<code class="descclassname">mpes.analysis.</code><code class="descname">applyWarping</code><span class="sig-paren">(</span><em>imgstack</em>, <em>axis</em>, <em>hgmat</em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.applyWarping" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply warping transform for a stack of images along an axis</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt>imgstack <span class="classifier-delimiter">:</span> <span class="classifier">3D array</span></dt>
<dd><p class="first last">Image stack before warping correction.</p>
</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Axis to iterate over to apply the transform.</p>
</dd>
<dt>hgmat <span class="classifier-delimiter">:</span> <span class="classifier">2D array</span></dt>
<dd><p class="first last">Homography matrix.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body"><dl class="first last docutils">
<dt>imstack_transformed <span class="classifier-delimiter">:</span> <span class="classifier">3D array</span></dt>
<dd><p class="first last">Stack of images after correction for warping.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mpes.analysis.apply_mask_along">
<code class="descclassname">mpes.analysis.</code><code class="descname">apply_mask_along</code><span class="sig-paren">(</span><em>arr</em>, <em>mask</em>, <em>axes=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.apply_mask_along" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a mask in a low dimensional slice throughout a high-dimensional array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt>arr <span class="classifier-delimiter">:</span> <span class="classifier">nD array</span></dt>
<dd><p class="first last">Multidimensional array for masking.</p>
</dd>
<dt>mask <span class="classifier-delimiter">:</span> <span class="classifier">nD array</span></dt>
<dd><p class="first last">Mask to apply.</p>
</dd>
<dt>axes <span class="classifier-delimiter">:</span> <span class="classifier">list/tuple of int | None</span></dt>
<dd><p class="first last">The axes to apply the mask to.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body"><dl class="first last docutils">
<dt>maskedarr <span class="classifier-delimiter">:</span> <span class="classifier">nD array</span></dt>
<dd><p class="first last">Masked multidimensional array.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mpes.analysis.bandpath_map">
<code class="descclassname">mpes.analysis.</code><code class="descname">bandpath_map</code><span class="sig-paren">(</span><em>bsvol</em>, <em>pathr=None</em>, <em>pathc=None</em>, <em>path_coords=None</em>, <em>eaxis=2</em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.bandpath_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract band diagram map from volumetric data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt>bsvol <span class="classifier-delimiter">:</span> <span class="classifier">3D array</span></dt>
<dd><p class="first last">Volumetric band structure data.</p>
</dd>
<dt>pathr, pathc <span class="classifier-delimiter">:</span> <span class="classifier">1D array | None, None</span></dt>
<dd><p class="first last">Row and column pixel coordinates along the band path (ignored if path_coords is given).</p>
</dd>
<dt>path_coords <span class="classifier-delimiter">:</span> <span class="classifier">2D array | None</span></dt>
<dd><p class="first last">Combined row and column pixel coordinates of the band path.</p>
</dd>
<dt>eaxis <span class="classifier-delimiter">:</span> <span class="classifier">int | 2</span></dt>
<dd><p class="first last">Energy axis index.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body"><dl class="first last docutils">
<dt>bpm <span class="classifier-delimiter">:</span> <span class="classifier">2D array</span></dt>
<dd><p class="first last">Band path map sampled from the volumetric data.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mpes.analysis.blocknorm">
<code class="descclassname">mpes.analysis.</code><code class="descname">blocknorm</code><span class="sig-paren">(</span><em>data</em>, <em>mavg_axis=0</em>, <em>blockwidth=1</em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.blocknorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Block-thresholding 2D data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt>data <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Data to normalize.</p>
</dd>
<dt>mavg_axis <span class="classifier-delimiter">:</span> <span class="classifier">int | 0</span></dt>
<dd><p class="first last">Axis to move the block along.</p>
</dd>
<dt>blockwidth <span class="classifier-delimiter">:</span> <span class="classifier">int | 1</span></dt>
<dd><p class="first last">Width of the moving block.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body"><dl class="first last docutils">
<dt>datanorm <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Block-normalized data.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mpes.analysis.bootstrapfit">
<code class="descclassname">mpes.analysis.</code><code class="descname">bootstrapfit</code><span class="sig-paren">(</span><em>data</em>, <em>axval</em>, <em>model</em>, <em>params</em>, <em>axis=0</em>, <em>dfcontainer=None</em>, <em>pbar=False</em>, <em>pbenv='classic'</em>, <em>ret='all'</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.bootstrapfit" title="Permalink to this definition">¶</a></dt>
<dd><p>Line-by-line fitting via bootstrapping fitted parameters from one line to the next.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt>data <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Data used in fitting.</p>
</dd>
<dt>axval <span class="classifier-delimiter">:</span> <span class="classifier">list/numeric array</span></dt>
<dd><p class="first last">Value for the axis.</p>
</dd>
<dt>model <span class="classifier-delimiter">:</span> <span class="classifier">lmfit Model object</span></dt>
<dd><p class="first last">The fitting model.</p>
</dd>
<dt>params <span class="classifier-delimiter">:</span> <span class="classifier">lmfit Parameters object</span></dt>
<dd><p class="first last">Initial guesses for fitting parameters.</p>
</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int | 0</span></dt>
<dd><p class="first last">The axis of the data to fit.</p>
</dd>
<dt>dfcontainer <span class="classifier-delimiter">:</span> <span class="classifier">pandas DataFrame | None</span></dt>
<dd><p class="first last">Dataframe container for the fitting parameters.</p>
</dd>
<dt>pbar <span class="classifier-delimiter">:</span> <span class="classifier">bool | False</span></dt>
<dd><p class="first last">Progress bar condition.</p>
</dd>
<dt>pbenv <span class="classifier-delimiter">:</span> <span class="classifier">str | ‘classic’</span></dt>
<dd><p class="first last">Progress bar environment (‘classic’ for generic version, ‘notebook’ for
notebook compatible version).</p>
</dd>
<dt><a href="#id41"><span class="problematic" id="id42">**</span></a>kwds <span class="classifier-delimiter">:</span> <span class="classifier">keyword arguments</span></dt>
<dd><table border="1" class="first last docutils">
<colgroup>
<col width="14%" />
<col width="11%" />
<col width="74%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">keyword</th>
<th class="head">data type</th>
<th class="head">meaning</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>maxiter</td>
<td>int</td>
<td>maximum iteration per fit (default = 20)</td>
</tr>
<tr class="row-odd"><td>concat</td>
<td>bool</td>
<td>concatenate the fit parameters to DataFrame input
False (default) = no concatenation, use an empty DataFrame to start
True = with concatenation to input DataFrame</td>
</tr>
<tr class="row-even"><td>bgremove</td>
<td>bool</td>
<td>toggle for background removal (default = True)</td>
</tr>
<tr class="row-odd"><td>flipped</td>
<td>bool</td>
<td>toggle for fitting start position
(if flipped, fitting start from the last line)</td>
</tr>
<tr class="row-even"><td>limpropagate</td>
<td>bool</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>verbose</td>
<td>bool</td>
<td>toggle for output message (default = False)</td>
</tr>
</tbody>
</table>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt>df_fit <span class="classifier-delimiter">:</span> <span class="classifier">pandas DataFrame</span></dt>
<dd><p class="first last">Dataframe container populated with obtained fitting parameters.</p>
</dd>
<dt>data_nobg <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Background-removed (Shirley-type) traces.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mpes.analysis.build_dynamic_matrix">
<code class="descclassname">mpes.analysis.</code><code class="descname">build_dynamic_matrix</code><span class="sig-paren">(</span><em>fitparams</em>, <em>display_range=slice(None</em>, <em>None</em>, <em>None)</em>, <em>pre_t0_range=slice(None</em>, <em>1</em>, <em>None)</em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.build_dynamic_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct the dynamic matrix from the fitting results:
for each fitting parameter, construct time-dependent value,
time-dependent absolute and relative changes</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt>fitparams <span class="classifier-delimiter">:</span> <span class="classifier">3D ndarray</span></dt>
<dd><p class="first last">fitting output</p>
</dd>
<dt>display_range <span class="classifier-delimiter">:</span> <span class="classifier">slice object | slice(None, None, None)</span></dt>
<dd><p class="first last">display time range of the fitting parameters (default = full range)</p>
</dd>
<dt>pre_t0_range <span class="classifier-delimiter">:</span> <span class="classifier">slice object | slice(None, 1, None)</span></dt>
<dd><p class="first last">time range regarded as before time-zero</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt>dyn_matrix <span class="classifier-delimiter">:</span> <span class="classifier">4D ndarray</span></dt>
<dd><p class="first last">calculated dynamic matrix</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mpes.analysis.calibrateE">
<code class="descclassname">mpes.analysis.</code><code class="descname">calibrateE</code><span class="sig-paren">(</span><em>pos</em>, <em>vals</em>, <em>order=3</em>, <em>refid=0</em>, <em>ret='func'</em>, <em>E0=None</em>, <em>t=None</em>, <em>aug=1</em>, <em>method='lstsq'</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.calibrateE" title="Permalink to this definition">¶</a></dt>
<dd><p>Energy calibration by nonlinear least squares fitting of spectral landmarks on
a set of (energy dispersion curves (EDCs). This amounts to solving for the
coefficient vector, a, in the system of equations T.a = b. Here T is the
differential drift time matrix and b the differential bias vector, and
assuming that the energy-drift-time relationship can be written in the form,
E = sum_n (a_n * t**n) + E0</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt>pos <span class="classifier-delimiter">:</span> <span class="classifier">list/array</span></dt>
<dd><p class="first last">Positions of the spectral landmarks (e.g. peaks) in the EDCs.</p>
</dd>
<dt>vals <span class="classifier-delimiter">:</span> <span class="classifier">list/array</span></dt>
<dd><p class="first last">Bias voltage value associated with each EDC.</p>
</dd>
<dt>order <span class="classifier-delimiter">:</span> <span class="classifier">int | 3</span></dt>
<dd><p class="first last">Polynomial order of the fitting function.</p>
</dd>
<dt>refid <span class="classifier-delimiter">:</span> <span class="classifier">int | 0</span></dt>
<dd><p class="first last">Reference dataset index, varies from 0 to vals.size - 1.</p>
</dd>
<dt>ret <span class="classifier-delimiter">:</span> <span class="classifier">str | ‘func’</span></dt>
<dd><p class="first last">Return type, including ‘func’, ‘coeffs’, ‘full’, and ‘axis’ (see below).</p>
</dd>
<dt>E0 <span class="classifier-delimiter">:</span> <span class="classifier">float | None</span></dt>
<dd><p class="first last">Constant energy offset.</p>
</dd>
<dt>t <span class="classifier-delimiter">:</span> <span class="classifier">numeric array | None</span></dt>
<dd><p class="first last">Drift time.</p>
</dd>
<dt>aug <span class="classifier-delimiter">:</span> <span class="classifier">int | 1</span></dt>
<dd><p class="first last">Fitting dimension augmentation (1=no change, 2=double, etc).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt>pfunc <span class="classifier-delimiter">:</span> <span class="classifier">partial function</span></dt>
<dd><p class="first last">Calibrating function with determined polynomial coefficients (except the constant offset).</p>
</dd>
<dt>ecalibdict <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">A dictionary of fitting parameters including the following,
:coeffs: Fitted polynomial coefficients (the a’s).
:offset: Minimum time-of-flight corresponding to a peak.
:Tmat: the T matrix (differential time-of-flight) in the equation Ta=b.
:bvec: the b vector (differential bias) in the fitting Ta=b.
:axis: Fitted energy axis.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mpes.analysis.calibrateK">
<code class="descclassname">mpes.analysis.</code><code class="descname">calibrateK</code><span class="sig-paren">(</span><em>img, pxla, pxlb, k_ab=None, kcoorda=None, kcoordb=[0.0, 0.0], equiscale=False, ret=['axes']</em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.calibrateK" title="Permalink to this definition">¶</a></dt>
<dd><p>Momentum axes calibration using the pixel positions of two symmetry points (a and b)
and the absolute coordinate of a single point (b), defaulted to [0., 0.]. All coordinates
should be specified in the (row_index, column_index) format. See the equiscale option for
details on the specifications of point coordinates.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt>img <span class="classifier-delimiter">:</span> <span class="classifier">2D array</span></dt>
<dd><p class="first last">An energy cut of the band structure.</p>
</dd>
<dt>pxla, pxlb <span class="classifier-delimiter">:</span> <span class="classifier">list/tuple/1D array</span></dt>
<dd><p class="first last">Pixel coordinates of the two symmetry points (a and b). Point b has the
default coordinates [0., 0.] (see below).</p>
</dd>
<dt>k_ab <span class="classifier-delimiter">:</span> <span class="classifier">float | None</span></dt>
<dd><p class="first last">The known momentum space distance between the two symmetry points.</p>
</dd>
<dt>kcoorda <span class="classifier-delimiter">:</span> <span class="classifier">list/tuple/1D array | None</span></dt>
<dd><p class="first last">Momentum coordinates of the symmetry point a.</p>
</dd>
<dt>kcoordb <span class="classifier-delimiter">:</span> <span class="classifier">list/tuple/1D array | [0., 0.]</span></dt>
<dd><p class="first last">Momentum coordinates of the symmetry point b (krow, kcol), default to k-space center.</p>
</dd>
<dt>equiscale <span class="classifier-delimiter">:</span> <span class="classifier">bool | False</span></dt>
<dd><p class="first last">Option to adopt equal scale along both the row and column directions.
:True: Use a uniform scale for both x and y directions in the image coordinate system.
This applies to the situation where the points a and b are (close to) parallel with one
of the two image axes.
:False: Calculate the momentum scale for both x and y directions separately. This applies
to the situation where the points a and b are sufficiently different in both x and y directions
in the image coordinate system.</p>
</dd>
<dt>ret <span class="classifier-delimiter">:</span> <span class="classifier">list | [‘axes’]</span></dt>
<dd><p class="first last">Return type specification, options include ‘axes’, ‘extent’, ‘coeffs’, ‘grid’, ‘func’, ‘all’.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt>k_row, k_col <span class="classifier-delimiter">:</span> <span class="classifier">1D array</span></dt>
<dd><p class="first last">Momentum coordinates of the row and column.</p>
</dd>
<dt>axis_extent <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">Extent of the two momentum axis (can be used directly in imshow).</p>
</dd>
<dt>k_rowgrid, k_colgrid <span class="classifier-delimiter">:</span> <span class="classifier">2D array</span></dt>
<dd><p class="first last">Row and column mesh grid generated from the coordinates
(can be used directly in pcolormesh).</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mpes.analysis.circmask">
<code class="descclassname">mpes.analysis.</code><code class="descname">circmask</code><span class="sig-paren">(</span><em>img</em>, <em>rcent</em>, <em>ccent</em>, <em>rad</em>, <em>sign=1</em>, <em>ret='mask'</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.circmask" title="Permalink to this definition">¶</a></dt>
<dd><p>Use a circular binary mask to cover an image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt>img <span class="classifier-delimiter">:</span> <span class="classifier">2D array</span></dt>
<dd><p class="first last">Input image to be masked.</p>
</dd>
<dt>rcent <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Row center position.</p>
</dd>
<dt>ccent <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Column center position.</p>
</dd>
<dt>rad <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Radius of circle.</p>
</dd>
<dt>sign <span class="classifier-delimiter">:</span> <span class="classifier">int/str | 1</span></dt>
<dd><p class="first last">Value of the masked region (0, 1, ‘nan’ or ‘xnan’).
‘xnan’ means the masked region is 1 and the other region nan.</p>
</dd>
<dt>ret <span class="classifier-delimiter">:</span> <span class="classifier">str | ‘mask’</span></dt>
<dd><p class="first last">Return type (‘mask’, ‘masked_image’)</p>
</dd>
<dt>kwds <span class="classifier-delimiter">:</span> <span class="classifier">keyword arguments</span></dt>
<dd><table border="1" class="first last docutils">
<colgroup>
<col width="22%" />
<col width="17%" />
<col width="20%" />
<col width="42%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">keyword</th>
<th class="head">data type</th>
<th class="head">default</th>
<th class="head">meaning</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>shape</td>
<td>tuple/list</td>
<td>shape of img</td>
<td>see skimage.draw.circle()</td>
</tr>
<tr class="row-odd"><td>method</td>
<td>str</td>
<td>‘graphic’</td>
<td>‘graphic’ or ‘algebraic’</td>
</tr>
<tr class="row-even"><td>edgefactor</td>
<td>float</td>
<td>1.02</td>
<td>prefactor to rad**2</td>
</tr>
</tbody>
</table>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body"><dl class="first last docutils">
<dt>cmask or cmask*img <span class="classifier-delimiter">:</span> <span class="classifier">2D array</span></dt>
<dd><p class="first last">Mask only or masked image</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mpes.analysis.curvature2d">
<code class="descclassname">mpes.analysis.</code><code class="descname">curvature2d</code><span class="sig-paren">(</span><em>image</em>, <em>cx=1</em>, <em>cy=1</em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.curvature2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Implementation of 2D curvature calculation.
The formula follows Zhang et al. Rev. Sci. Instrum. 82, 043712 (2011).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt>image <span class="classifier-delimiter">:</span> <span class="classifier">2D array</span></dt>
<dd><p class="first last">2D image obtained from measurement.</p>
</dd>
<dt>cx, cy <span class="classifier-delimiter">:</span> <span class="classifier">numeric, numeric | 1, 1</span></dt>
<dd><p class="first last">Scaling parameters in x and y directions.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mpes.analysis.fitEllipseParams">
<code class="descclassname">mpes.analysis.</code><code class="descname">fitEllipseParams</code><span class="sig-paren">(</span><em>*coords</em>, <em>plot=False</em>, <em>img=None</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.fitEllipseParams" title="Permalink to this definition">¶</a></dt>
<dd><p>Direct least-squares method for fitting ellipse from scattered points</p>
</dd></dl>

<dl class="function">
<dt id="mpes.analysis.func_add">
<code class="descclassname">mpes.analysis.</code><code class="descname">func_add</code><span class="sig-paren">(</span><em>*funcs</em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.func_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Addition of an arbitray number of functions</p>
<p><strong>*Parameters*</strong></p>
<dl class="docutils">
<dt><a href="#id43"><span class="problematic" id="id44">*</span></a>funcs <span class="classifier-delimiter">:</span> <span class="classifier">list/tuple</span></dt>
<dd>functions to combine</dd>
</dl>
<p><strong>*Returns*</strong></p>
<dl class="docutils">
<dt>funcsum <span class="classifier-delimiter">:</span> <span class="classifier">function</span></dt>
<dd>functional sum</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="mpes.analysis.func_update">
<code class="descclassname">mpes.analysis.</code><code class="descname">func_update</code><span class="sig-paren">(</span><em>func</em>, <em>suffix=''</em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.func_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Attach a suffix to parameter names and their instances
in the expression of a function</p>
<p><strong>*Parameters*</strong></p>
<dl class="docutils">
<dt>func <span class="classifier-delimiter">:</span> <span class="classifier">function</span></dt>
<dd>input function</dd>
<dt>suffix <span class="classifier-delimiter">:</span> <span class="classifier">str | ‘’</span></dt>
<dd>suffix to attach to parameter names</dd>
</dl>
<p><strong>*Returns*</strong></p>
<dl class="docutils">
<dt>params <span class="classifier-delimiter">:</span> <span class="classifier">list of str</span></dt>
<dd>updated function parameters</dd>
<dt>expr <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>updated function expression</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="mpes.analysis.gaussian">
<code class="descclassname">mpes.analysis.</code><code class="descname">gaussian</code><span class="sig-paren">(</span><em>feval=False</em>, <em>vardict=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.gaussian" title="Permalink to this definition">¶</a></dt>
<dd><p>Gaussian model</p>
</dd></dl>

<dl class="function">
<dt id="mpes.analysis.gradn">
<code class="descclassname">mpes.analysis.</code><code class="descname">gradn</code><span class="sig-paren">(</span><em>array</em>, <em>axes</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.gradn" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate nth-order gradients of the array along different directions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt>array <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd><p class="first last">N-dimensional matrix for calculating the gradient.</p>
</dd>
<dt>axes <span class="classifier-delimiter">:</span> <span class="classifier">int/list/tuple/1D array</span></dt>
<dd><p class="first last">A sequence of axes (from first to last) to calculate the gradient.
When input a single integer, the gradient is calculated along that particular axis.
For example, the 4th-order mixed gradient d4f/(dxdydxdy) requires the sequence (1, 0, 1, 0).</p>
</dd>
<dt><a href="#id45"><span class="problematic" id="id46">**</span></a>kwds <span class="classifier-delimiter">:</span> <span class="classifier">keyword arguments</span></dt>
<dd><p class="first last">See <code class="docutils literal"><span class="pre">numpy.gradient()</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mpes.analysis.peakdetect1d">
<code class="descclassname">mpes.analysis.</code><code class="descname">peakdetect1d</code><span class="sig-paren">(</span><em>y_axis</em>, <em>x_axis=None</em>, <em>lookahead=200</em>, <em>delta=0</em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.peakdetect1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Function for detecting local maxima and minima in a signal.
Discovers peaks by searching for values which are surrounded by lower
or larger values for maxima and minima respectively</p>
<p>Converted from/based on a MATLAB script at:
<a class="reference external" href="http://billauer.co.il/peakdet.html">http://billauer.co.il/peakdet.html</a></p>
<p><strong>Parameters</strong>
y_axis : list</p>
<blockquote>
<div>A list containing the signal over which to find peaks</div></blockquote>
<dl class="docutils">
<dt>x_axis <span class="classifier-delimiter">:</span> <span class="classifier">list | None</span></dt>
<dd>A x-axis whose values correspond to the y_axis list and is used
in the return to specify the position of the peaks. If omitted an
index of the y_axis is used.</dd>
<dt>lookahead <span class="classifier-delimiter">:</span> <span class="classifier">int | 200</span></dt>
<dd>distance to look ahead from a peak candidate to determine if
it is the actual peak
‘(samples / period) / f’ where ‘4 &gt;= f &gt;= 1.25’ might be a good value</dd>
<dt>delta <span class="classifier-delimiter">:</span> <span class="classifier">numeric | 0</span></dt>
<dd>this specifies a minimum difference between a peak and
the following points, before a peak may be considered a peak. Useful
to hinder the function from picking up false peaks towards to end of
the signal. To work well delta should be set to delta &gt;= RMSnoise * 5.</dd>
</dl>
<p><strong>Returns</strong>
max_peaks : list</p>
<blockquote>
<div>positions of the positive peaks</div></blockquote>
<dl class="docutils">
<dt>min_peaks <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd>positions of the negative peaks</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="mpes.analysis.peakdetect2d">
<code class="descclassname">mpes.analysis.</code><code class="descname">peakdetect2d</code><span class="sig-paren">(</span><em>img</em>, <em>method='daofind'</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.peakdetect2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Peak-like feature detection in a 2D image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt>img <span class="classifier-delimiter">:</span> <span class="classifier">2D array</span></dt>
<dd><p class="first last">Image matrix.</p>
</dd>
<dt>method <span class="classifier-delimiter">:</span> <span class="classifier">str | ‘daofind’</span></dt>
<dd><p class="first last">Detection method (‘daofind’ or ‘maxlist’).</p>
</dd>
<dt><a href="#id47"><span class="problematic" id="id48">**</span></a>kwds <span class="classifier-delimiter">:</span> <span class="classifier">keyword arguments</span></dt>
<dd><p class="first">Arguments passed to the specific methods chosen.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">daofind:</th><td class="field-body">See <code class="docutils literal"><span class="pre">astropy.stats.sigma_clipped_stats()</span></code> and <code class="docutils literal"><span class="pre">photutils.detection.DAOStarFinder()</span></code>.</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>sigma <span class="classifier-delimiter">:</span> <span class="classifier">float | 5.0</span></dt>
<dd><p class="first last">Standard deviation of the clipping Gaussian.</p>
</dd>
<dt>fwhm <span class="classifier-delimiter">:</span> <span class="classifier">float | 3.0</span></dt>
<dd><p class="first last">FWHM of the convoluting Gaussian kernel.</p>
</dd>
<dt>threshfactor <span class="classifier-delimiter">:</span> <span class="classifier">float | 8</span></dt>
<dd><p class="first last">Intensity threshold for background-foreground separation (foreground is above threshold).</p>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">maxlist:</th><td class="field-body">See <code class="docutils literal"><span class="pre">skimage.feature.peak_local_max()</span></code>.</td>
</tr>
</tbody>
</table>
<dl class="last docutils">
<dt>mindist <span class="classifier-delimiter">:</span> <span class="classifier">float | 10</span></dt>
<dd><p class="first last">Minimal distance between two local maxima.</p>
</dd>
<dt>numpeaks <span class="classifier-delimiter">:</span> <span class="classifier">int | 7</span></dt>
<dd><p class="first last">Maximum number of detected peaks.</p>
</dd>
</dl>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body"><dl class="first last docutils">
<dt>pks <span class="classifier-delimiter">:</span> <span class="classifier">2D array</span></dt>
<dd><p class="first last">Pixel coordinates of detected peaks, in (column, row) ordering.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mpes.analysis.peaksearch">
<code class="descclassname">mpes.analysis.</code><code class="descname">peaksearch</code><span class="sig-paren">(</span><em>traces</em>, <em>tof</em>, <em>ranges=None</em>, <em>method='range-limited'</em>, <em>pkwindow=3</em>, <em>plot=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.peaksearch" title="Permalink to this definition">¶</a></dt>
<dd><p>Detect a list of peaks in the corresponding regions of multiple EDCs</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt>traces <span class="classifier-delimiter">:</span> <span class="classifier">2D array</span></dt>
<dd><p class="first last">Collection of EDCs.</p>
</dd>
<dt>tof <span class="classifier-delimiter">:</span> <span class="classifier">1D array</span></dt>
<dd><p class="first last">Time-of-flight values.</p>
</dd>
<dt>ranges <span class="classifier-delimiter">:</span> <span class="classifier">list of tuples/lists | None</span></dt>
<dd><p class="first last">List of ranges for peak detection in the format
[(LowerBound1, UpperBound1), (LowerBound2, UpperBound2), ….].</p>
</dd>
<dt>method <span class="classifier-delimiter">:</span> <span class="classifier">str | ‘range-limited’</span></dt>
<dd><p class="first last">Method for peak-finding (‘range-limited’ and ‘alignment’).</p>
</dd>
<dt>pkwindow <span class="classifier-delimiter">:</span> <span class="classifier">int | 3</span></dt>
<dd><p class="first last">Window width of a peak(amounts to lookahead in <code class="docutils literal"><span class="pre">mpes.analysis.peakdetect1d</span></code>).</p>
</dd>
<dt>plot <span class="classifier-delimiter">:</span> <span class="classifier">bool | False</span></dt>
<dd><p class="first last">Specify whether to display a custom plot of the peak search results.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt>pkmaxs <span class="classifier-delimiter">:</span> <span class="classifier">1D array</span></dt>
<dd><p class="first last">Collection of peak positions</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mpes.analysis.points2path">
<code class="descclassname">mpes.analysis.</code><code class="descname">points2path</code><span class="sig-paren">(</span><em>pointsr</em>, <em>pointsc</em>, <em>ret='separated'</em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.points2path" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate ordered pixel cooridnates along a path defined by specific intermediate points.
The approach constructs the path using a set of line segments bridging the specified points,
therefore it is also able to trace the sequence indices of these special points.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt>pointsr, pointsc <span class="classifier-delimiter">:</span> <span class="classifier">list/tuple/array</span></dt>
<dd><p class="first last">The row and column pixel coordinates of the special points along the sampling path.</p>
</dd>
<dt>ret <span class="classifier-delimiter">:</span> <span class="classifier">str | ‘separated’</span></dt>
<dd><p class="first last">Specify if return combined (‘combined’) or separated (‘separated’) row and column coordinates.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt>polyr, polyc <span class="classifier-delimiter">:</span> <span class="classifier">1D array</span></dt>
<dd><p class="first last">Pixel coordinates along the path traced out sequentially.</p>
</dd>
<dt>pid <span class="classifier-delimiter">:</span> <span class="classifier">1D array</span></dt>
<dd><p class="first last">Pointwise indices of the special lpoints.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mpes.analysis.rangeConvert">
<code class="descclassname">mpes.analysis.</code><code class="descname">rangeConvert</code><span class="sig-paren">(</span><em>x</em>, <em>xrng</em>, <em>pathcorr</em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.rangeConvert" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert value range using a pairwise path correspondence (e.g. obtained
from time warping techniques).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt>x <span class="classifier-delimiter">:</span> <span class="classifier">1D array</span></dt>
<dd><p class="first last">Values of the x axis (e.g. time-of-flight values).</p>
</dd>
<dt>xrng <span class="classifier-delimiter">:</span> <span class="classifier">list/tuple</span></dt>
<dd><p class="first last">Boundary value range on the x axis.</p>
</dd>
<dt>pathcorr <span class="classifier-delimiter">:</span> <span class="classifier">list/tuple</span></dt>
<dd><p class="first last">Path correspondence between two 1D arrays in the following form,
[(id_1_trace_1, id_1_trace_2), (id_2_trace_1, id_2_trace_2), …]</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body"><dl class="first last docutils">
<dt>xrange_trans <span class="classifier-delimiter">:</span> <span class="classifier">tuple</span></dt>
<dd><p class="first last">Transformed range according to the path correspondence.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mpes.analysis.rectmask">
<code class="descclassname">mpes.analysis.</code><code class="descname">rectmask</code><span class="sig-paren">(</span><em>img</em>, <em>rcent</em>, <em>ccent</em>, <em>shift</em>, <em>direction='row'</em>, <em>sign=1</em>, <em>ret='mask'</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.rectmask" title="Permalink to this definition">¶</a></dt>
<dd><p>Use a rectangular binary mask to cover an image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt>img <span class="classifier-delimiter">:</span> <span class="classifier">2D array</span></dt>
<dd><p class="first last">Input image to be masked</p>
</dd>
<dt>rcent <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Row center position</p>
</dd>
<dt>ccent <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Column center position</p>
</dd>
<dt>shift <span class="classifier-delimiter">:</span> <span class="classifier">int/list of int</span></dt>
<dd><p class="first last">Pixel shifts</p>
</dd>
<dt>direction <span class="classifier-delimiter">:</span> <span class="classifier">str | ‘row’</span></dt>
<dd><p class="first last">Direction to apply the shift to, ‘row’ or ‘column’ indicates row-wise
or column-wise shift for generating the rectangular mask</p>
</dd>
<dt>sign <span class="classifier-delimiter">:</span> <span class="classifier">int/str | 1</span></dt>
<dd><p class="first last">Value of the masked region (0, 1, ‘nan’ or ‘xnan’).
‘xnan’ means the masked region is 1 and the other region nan.</p>
</dd>
<dt>ret <span class="classifier-delimiter">:</span> <span class="classifier">str | ‘mask’</span></dt>
<dd><p class="first last">Return type (‘mask’, ‘masked_image’)</p>
</dd>
</dl>
<p><a href="#id49"><span class="problematic" id="id50">**</span></a>kwds : keyword arguments</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body"><dl class="first last docutils">
<dt>cmask or cmask*img <span class="classifier-delimiter">:</span> <span class="classifier">2D array</span></dt>
<dd><p class="first last">Mask only or masked image</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mpes.analysis.regionExpand">
<code class="descclassname">mpes.analysis.</code><code class="descname">regionExpand</code><span class="sig-paren">(</span><em>mask</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.regionExpand" title="Permalink to this definition">¶</a></dt>
<dd><p>Expand the region of a binarized image around a line position</p>
<p><strong>Parameters</strong>
mask : numeric binarized 2D array</p>
<blockquote>
<div>the mask to be expanded</div></blockquote>
<dl class="docutils">
<dt><a href="#id51"><span class="problematic" id="id52">**</span></a>kwds <span class="classifier-delimiter">:</span> <span class="classifier">keyword arguments</span></dt>
<dd><table border="1" class="first last docutils">
<colgroup>
<col width="21%" />
<col width="16%" />
<col width="62%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">keyword</th>
<th class="head">data type</th>
<th class="head">meaning</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>method</td>
<td>str</td>
<td>method of choice (‘offset’, ‘growth’)</td>
</tr>
<tr class="row-odd"><td>value</td>
<td>numeric</td>
<td>value to be assigned to the masked</td>
</tr>
<tr class="row-even"><td>linecoords</td>
<td>2D array</td>
<td>contains x and y positions of the line</td>
</tr>
<tr class="row-odd"><td>axoffsets</td>
<td>tuple/list</td>
<td>[downshift upshift] pixel number</td>
</tr>
<tr class="row-even"><td>clipbounds</td>
<td>tuple/list</td>
<td>bounds in the clipping direction</td>
</tr>
<tr class="row-odd"><td>selem</td>
<td>ndarray</td>
<td>structuring element</td>
</tr>
</tbody>
</table>
</dd>
</dl>
<p><strong>Return</strong>
mask : numeric 2D array</p>
<blockquote>
<div>modified mask (returns the original mask if insufficient arguments
are provided for the chosen method for region expansion)</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="mpes.analysis.ridgeDetect">
<code class="descclassname">mpes.analysis.</code><code class="descname">ridgeDetect</code><span class="sig-paren">(</span><em>mask</em>, <em>method='mask_mean_y'</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.ridgeDetect" title="Permalink to this definition">¶</a></dt>
<dd><p>Detect the band ridges using selected methods.</p>
<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt>mask <span class="classifier-delimiter">:</span> <span class="classifier">numeric 2D array</span></dt>
<dd>the 2D integer-valued mask with labeled bands</dd>
<dt>method <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>the method used for ridge detection
‘mask_mean_y’ : mean mask position along y direction (default)
‘mask_mean_x’ : mean mask position along x direction</dd>
<dt><a href="#id53"><span class="problematic" id="id54">**</span></a>kwds <span class="classifier-delimiter">:</span> <span class="classifier">keyword arguments</span></dt>
<dd><table border="1" class="first last docutils">
<colgroup>
<col width="20%" />
<col width="26%" />
<col width="54%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">keyword</th>
<th class="head">data type</th>
<th class="head">meaning</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>x</td>
<td>int/float</td>
<td>x axis coordinates</td>
</tr>
<tr class="row-odd"><td>y</td>
<td>int/float</td>
<td>y axis coordinates</td>
</tr>
</tbody>
</table>
</dd>
</dl>
<p><strong>Return</strong></p>
<dl class="docutils">
<dt>ridges <span class="classifier-delimiter">:</span> <span class="classifier">list of dataframes</span></dt>
<dd>the ridge coordinates</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="mpes.analysis.segment2d">
<code class="descclassname">mpes.analysis.</code><code class="descname">segment2d</code><span class="sig-paren">(</span><em>img</em>, <em>nbands=1</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.segment2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Electronic band segmentation using local thresholding
and connected component labeling</p>
<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt>img <span class="classifier-delimiter">:</span> <span class="classifier">2D numeric array</span></dt>
<dd>the 2D matrix to segment</dd>
<dt>nbands <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of electronic bands</dd>
</dl>
<p><a href="#id55"><span class="problematic" id="id56">**</span></a>kwds : keyword arguments</p>
<p><strong>Return</strong></p>
<dl class="docutils">
<dt>imglabeled <span class="classifier-delimiter">:</span> <span class="classifier">2D numeric array</span></dt>
<dd>labeled mask</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="mpes.analysis.shirley">
<code class="descclassname">mpes.analysis.</code><code class="descname">shirley</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>tol=1e-05</em>, <em>maxiter=20</em>, <em>explicit=False</em>, <em>warning=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.shirley" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the 1D best Shirley-Proctor-Sherwood background S for a dataset (x, y).
A. Proctor, P. M. A. Sherwood, Anal. Chem. 54 13 (1982).
The function is adapted from Kane O’Donnell’s routine
1. Finds the biggest peak
2. Use the minimum value on either side of this peak as the terminal points
of the Shirley background.
3. Iterate over the process within maximum allowed iteration (maxiter) to
reach the tolerance level (tol).</p>
<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt>x <span class="classifier-delimiter">:</span> <span class="classifier">1D numeric array</span></dt>
<dd>the photoelectron energy axis</dd>
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">1D numeric array</span></dt>
<dd>the photoemission intensity axis</dd>
<dt>tol <span class="classifier-delimiter">:</span> <span class="classifier">float | 1e-5</span></dt>
<dd>fitting tolerance</dd>
<dt>maxiter <span class="classifier-delimiter">:</span> <span class="classifier">int | 20</span></dt>
<dd>maximal iteration</dd>
<dt>explicit <span class="classifier-delimiter">:</span> <span class="classifier">bool | False</span></dt>
<dd>explicit display of iteration number</dd>
<dt>warning <span class="classifier-delimiter">:</span> <span class="classifier">bool | False</span></dt>
<dd>display of warnings during calculation</dd>
</dl>
<p><strong>Return</strong></p>
<dl class="docutils">
<dt>sbg <span class="classifier-delimiter">:</span> <span class="classifier">1D numeric array</span></dt>
<dd>Calculated Shirley background</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="mpes.analysis.shirley2d">
<code class="descclassname">mpes.analysis.</code><code class="descname">shirley2d</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>tol=1e-05</em>, <em>maxiter=20</em>, <em>explicit=False</em>, <em>warning=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.shirley2d" title="Permalink to this definition">¶</a></dt>
<dd><p>2D Shirley background removal</p>
</dd></dl>

<dl class="function">
<dt id="mpes.analysis.vertexGenerator">
<code class="descclassname">mpes.analysis.</code><code class="descname">vertexGenerator</code><span class="sig-paren">(</span><em>center</em>, <em>fixedvertex=None</em>, <em>cvd=None</em>, <em>arot=None</em>, <em>nside=None</em>, <em>direction=-1</em>, <em>scale=1</em>, <em>diagdir=None</em>, <em>ret='all'</em>, <em>rettype='float32'</em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.vertexGenerator" title="Permalink to this definition">¶</a></dt>
<dd><p>Generation of the vertices of symmetric polygons.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt>center <span class="classifier-delimiter">:</span> <span class="classifier">(int, int)</span></dt>
<dd><p class="first last">Pixel positions of the symmetry center (row pixel, column pixel).</p>
</dd>
<dt>fixedvertex <span class="classifier-delimiter">:</span> <span class="classifier">(int, int) | None</span></dt>
<dd><p class="first last">Pixel position of the fixed vertex (row pixel, column pixel).</p>
</dd>
<dt>cvd <span class="classifier-delimiter">:</span> <span class="classifier">numeric | None</span></dt>
<dd><p class="first last">Center-vertex distance.</p>
</dd>
<dt>arot <span class="classifier-delimiter">:</span> <span class="classifier">float | None</span></dt>
<dd><p class="first last">Spacing in angle of rotation.</p>
</dd>
<dt>nside <span class="classifier-delimiter">:</span> <span class="classifier">int | None</span></dt>
<dd><p class="first last">The total number of sides for the polygon.</p>
</dd>
<dt>direction <span class="classifier-delimiter">:</span> <span class="classifier">int | -1</span></dt>
<dd><p class="first last">Direction of angular rotation (1 = counterclockwise, -1 = clockwise)</p>
</dd>
<dt>scale <span class="classifier-delimiter">:</span> <span class="classifier">float | 1</span></dt>
<dd><p class="first last">Radial scaling factor.</p>
</dd>
<dt>diagdir <span class="classifier-delimiter">:</span> <span class="classifier">str | None</span></dt>
<dd><p class="first last">Diagonal direction of the polygon (‘x’ or ‘y’).</p>
</dd>
<dt>ret <span class="classifier-delimiter">:</span> <span class="classifier">str | ‘all’</span></dt>
<dd><p class="first last">Return type. Specify ‘all’ returns all vertices, specify ‘generated’
returns only the generated ones (without the fixedvertex in the argument).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return:</th><td class="field-body"><dl class="first last docutils">
<dt>vertices <span class="classifier-delimiter">:</span> <span class="classifier">2D array</span></dt>
<dd><p class="first last">Collection of generated vertices.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mpes.analysis.voigt">
<code class="descclassname">mpes.analysis.</code><code class="descname">voigt</code><span class="sig-paren">(</span><em>feval=False</em>, <em>vardict=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mpes.analysis.voigt" title="Permalink to this definition">¶</a></dt>
<dd><p>Voigt model</p>
</dd></dl>

</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="visualization.html" class="btn btn-neutral float-right" title="Visualization" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="file_io.html" class="btn btn-neutral" title="File I/O &amp; Processing" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, R. Patrick Xian.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>